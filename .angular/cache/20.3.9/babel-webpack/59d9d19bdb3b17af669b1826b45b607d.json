{"ast":null,"code":"import { __decorate, __metadata } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./dcx-ng-tooltip.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./dcx-ng-tooltip.component.scss?ngResource\";\nimport { Component, Input, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nexport var TooltipPosition;\n(function (TooltipPosition) {\n  TooltipPosition[\"TOP\"] = \"top\";\n  TooltipPosition[\"BOTTOM\"] = \"bottom\";\n  TooltipPosition[\"LEFT\"] = \"left\";\n  TooltipPosition[\"RIGHT\"] = \"right\";\n})(TooltipPosition || (TooltipPosition = {}));\nlet DcxNgTooltipComponent = class DcxNgTooltipComponent {\n  elementRef;\n  position = TooltipPosition.TOP;\n  hideTooltipOnClick = false;\n  content = '';\n  visible = false;\n  actualPosition = TooltipPosition.TOP;\n  tooltipElement;\n  onMouseEnter() {\n    this.visible = true;\n    this.adjustPosition();\n  }\n  onMouseLeave() {\n    this.visible = false;\n  }\n  onDocumentClick(event) {\n    if (this.hideTooltipOnClick) {\n      const clickedInside = this.elementRef.nativeElement.contains(event.target);\n      if (clickedInside) {\n        this.visible = false;\n      }\n    }\n  }\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n  ngAfterViewInit() {\n    this.actualPosition = this.position;\n  }\n  adjustPosition() {\n    setTimeout(() => {\n      const tooltipEl = this.tooltipElement.nativeElement;\n      const hostEl = this.elementRef.nativeElement;\n      // Get viewport dimensions\n      const viewport = {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n      // Get host element position and dimensions\n      const hostRect = hostEl.getBoundingClientRect();\n      // Get tooltip dimensions\n      const tooltipRect = tooltipEl.getBoundingClientRect();\n      // Calculate available space in each direction\n      const spaceTop = hostRect.top;\n      const spaceBottom = viewport.height - hostRect.bottom;\n      const spaceLeft = hostRect.left;\n      const spaceRight = viewport.width - hostRect.right;\n      // Determine the best position based on available space\n      const optimalPosition = this.calculateOptimalPosition(this.position, tooltipRect, {\n        spaceTop,\n        spaceBottom,\n        spaceLeft,\n        spaceRight\n      });\n      if (optimalPosition !== this.actualPosition) {\n        this.actualPosition = optimalPosition;\n      }\n    }, 10);\n  }\n  calculateOptimalPosition(preferredPosition, tooltipRect, availableSpace) {\n    const margin = 10; // Safety margin\n    const tooltipHeight = tooltipRect.height;\n    const tooltipWidth = tooltipRect.width;\n    // Check if preferred position fits\n    switch (preferredPosition) {\n      case TooltipPosition.TOP:\n        if (availableSpace.spaceTop >= tooltipHeight + margin) {\n          return TooltipPosition.TOP;\n        }\n        break;\n      case TooltipPosition.BOTTOM:\n        if (availableSpace.spaceBottom >= tooltipHeight + margin) {\n          return TooltipPosition.BOTTOM;\n        }\n        break;\n      case TooltipPosition.LEFT:\n        if (availableSpace.spaceLeft >= tooltipWidth + margin) {\n          return TooltipPosition.LEFT;\n        }\n        break;\n      case TooltipPosition.RIGHT:\n        if (availableSpace.spaceRight >= tooltipWidth + margin) {\n          return TooltipPosition.RIGHT;\n        }\n        break;\n    }\n    // If preferred position doesn't fit, find the best alternative\n    const alternatives = [{\n      position: TooltipPosition.TOP,\n      space: availableSpace.spaceTop\n    }, {\n      position: TooltipPosition.BOTTOM,\n      space: availableSpace.spaceBottom\n    }, {\n      position: TooltipPosition.LEFT,\n      space: availableSpace.spaceLeft\n    }, {\n      position: TooltipPosition.RIGHT,\n      space: availableSpace.spaceRight\n    }];\n    // Sort by available space (descending)\n    alternatives.sort((a, b) => b.space - a.space);\n    // Return the position with the most space that fits\n    for (const alt of alternatives) {\n      const requiredSpace = alt.position === TooltipPosition.LEFT || alt.position === TooltipPosition.RIGHT ? tooltipWidth + margin : tooltipHeight + margin;\n      if (alt.space >= requiredSpace) {\n        return alt.position;\n      }\n    }\n    // If nothing fits perfectly, return the one with most space\n    return alternatives[0].position;\n  }\n  getTooltipClasses() {\n    const baseClass = 'dcx-ng-tooltip';\n    const positionClass = `${baseClass}--${this.actualPosition}`;\n    return `${baseClass} ${positionClass}`.trim();\n  }\n  static ctorParameters = () => [{\n    type: ElementRef\n  }];\n  static propDecorators = {\n    position: [{\n      type: Input\n    }],\n    hideTooltipOnClick: [{\n      type: Input\n    }],\n    content: [{\n      type: Input\n    }],\n    tooltipElement: [{\n      type: ViewChild,\n      args: ['tooltipElement']\n    }],\n    onMouseEnter: [{\n      type: HostListener,\n      args: ['mouseenter']\n    }],\n    onMouseLeave: [{\n      type: HostListener,\n      args: ['mouseleave']\n    }],\n    onDocumentClick: [{\n      type: HostListener,\n      args: ['document:click', ['$event']]\n    }]\n  };\n};\nDcxNgTooltipComponent = __decorate([Component({\n  selector: 'dcx-ng-tooltip',\n  standalone: true,\n  imports: [CommonModule],\n  template: __NG_CLI_RESOURCE__0,\n  styles: [__NG_CLI_RESOURCE__1]\n}), __metadata(\"design:paramtypes\", [ElementRef])], DcxNgTooltipComponent);\nexport { DcxNgTooltipComponent };","map":{"version":3,"names":["__decorate","__metadata","__NG_CLI_RESOURCE__0","__NG_CLI_RESOURCE__1","Component","Input","HostListener","ElementRef","ViewChild","CommonModule","TooltipPosition","DcxNgTooltipComponent","elementRef","position","TOP","hideTooltipOnClick","content","visible","actualPosition","tooltipElement","onMouseEnter","adjustPosition","onMouseLeave","onDocumentClick","event","clickedInside","nativeElement","contains","target","constructor","ngAfterViewInit","setTimeout","tooltipEl","hostEl","viewport","width","window","innerWidth","height","innerHeight","hostRect","getBoundingClientRect","tooltipRect","spaceTop","top","spaceBottom","bottom","spaceLeft","left","spaceRight","right","optimalPosition","calculateOptimalPosition","preferredPosition","availableSpace","margin","tooltipHeight","tooltipWidth","BOTTOM","LEFT","RIGHT","alternatives","space","sort","a","b","alt","requiredSpace","getTooltipClasses","baseClass","positionClass","trim","ctorParameters","type","propDecorators","args","selector","standalone","imports","template","styles"],"sources":["C:/Users/lgarci16/Desktop/libreria-formacion/libs/dcx-ng-lib/src/lib/dcx-ng-components/dcx-ng-tooltip/dcx-ng-tooltip.component.ts"],"sourcesContent":["import { __decorate, __metadata } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./dcx-ng-tooltip.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./dcx-ng-tooltip.component.scss?ngResource\";\nimport { Component, Input, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nexport var TooltipPosition;\n(function (TooltipPosition) {\n    TooltipPosition[\"TOP\"] = \"top\";\n    TooltipPosition[\"BOTTOM\"] = \"bottom\";\n    TooltipPosition[\"LEFT\"] = \"left\";\n    TooltipPosition[\"RIGHT\"] = \"right\";\n})(TooltipPosition || (TooltipPosition = {}));\nlet DcxNgTooltipComponent = class DcxNgTooltipComponent {\n    elementRef;\n    position = TooltipPosition.TOP;\n    hideTooltipOnClick = false;\n    content = '';\n    visible = false;\n    actualPosition = TooltipPosition.TOP;\n    tooltipElement;\n    onMouseEnter() {\n        this.visible = true;\n        this.adjustPosition();\n    }\n    onMouseLeave() {\n        this.visible = false;\n    }\n    onDocumentClick(event) {\n        if (this.hideTooltipOnClick) {\n            const clickedInside = this.elementRef.nativeElement.contains(event.target);\n            if (clickedInside) {\n                this.visible = false;\n            }\n        }\n    }\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n    ngAfterViewInit() {\n        this.actualPosition = this.position;\n    }\n    adjustPosition() {\n        setTimeout(() => {\n            const tooltipEl = this.tooltipElement.nativeElement;\n            const hostEl = this.elementRef.nativeElement;\n            // Get viewport dimensions\n            const viewport = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n            // Get host element position and dimensions\n            const hostRect = hostEl.getBoundingClientRect();\n            // Get tooltip dimensions\n            const tooltipRect = tooltipEl.getBoundingClientRect();\n            // Calculate available space in each direction\n            const spaceTop = hostRect.top;\n            const spaceBottom = viewport.height - hostRect.bottom;\n            const spaceLeft = hostRect.left;\n            const spaceRight = viewport.width - hostRect.right;\n            // Determine the best position based on available space\n            const optimalPosition = this.calculateOptimalPosition(this.position, tooltipRect, { spaceTop, spaceBottom, spaceLeft, spaceRight });\n            if (optimalPosition !== this.actualPosition) {\n                this.actualPosition = optimalPosition;\n            }\n        }, 10);\n    }\n    calculateOptimalPosition(preferredPosition, tooltipRect, availableSpace) {\n        const margin = 10; // Safety margin\n        const tooltipHeight = tooltipRect.height;\n        const tooltipWidth = tooltipRect.width;\n        // Check if preferred position fits\n        switch (preferredPosition) {\n            case TooltipPosition.TOP:\n                if (availableSpace.spaceTop >= tooltipHeight + margin) {\n                    return TooltipPosition.TOP;\n                }\n                break;\n            case TooltipPosition.BOTTOM:\n                if (availableSpace.spaceBottom >= tooltipHeight + margin) {\n                    return TooltipPosition.BOTTOM;\n                }\n                break;\n            case TooltipPosition.LEFT:\n                if (availableSpace.spaceLeft >= tooltipWidth + margin) {\n                    return TooltipPosition.LEFT;\n                }\n                break;\n            case TooltipPosition.RIGHT:\n                if (availableSpace.spaceRight >= tooltipWidth + margin) {\n                    return TooltipPosition.RIGHT;\n                }\n                break;\n        }\n        // If preferred position doesn't fit, find the best alternative\n        const alternatives = [\n            { position: TooltipPosition.TOP, space: availableSpace.spaceTop },\n            { position: TooltipPosition.BOTTOM, space: availableSpace.spaceBottom },\n            { position: TooltipPosition.LEFT, space: availableSpace.spaceLeft },\n            { position: TooltipPosition.RIGHT, space: availableSpace.spaceRight }\n        ];\n        // Sort by available space (descending)\n        alternatives.sort((a, b) => b.space - a.space);\n        // Return the position with the most space that fits\n        for (const alt of alternatives) {\n            const requiredSpace = (alt.position === TooltipPosition.LEFT || alt.position === TooltipPosition.RIGHT)\n                ? tooltipWidth + margin\n                : tooltipHeight + margin;\n            if (alt.space >= requiredSpace) {\n                return alt.position;\n            }\n        }\n        // If nothing fits perfectly, return the one with most space\n        return alternatives[0].position;\n    }\n    getTooltipClasses() {\n        const baseClass = 'dcx-ng-tooltip';\n        const positionClass = `${baseClass}--${this.actualPosition}`;\n        return `${baseClass} ${positionClass}`.trim();\n    }\n    static ctorParameters = () => [\n        { type: ElementRef }\n    ];\n    static propDecorators = {\n        position: [{ type: Input }],\n        hideTooltipOnClick: [{ type: Input }],\n        content: [{ type: Input }],\n        tooltipElement: [{ type: ViewChild, args: ['tooltipElement',] }],\n        onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],\n        onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],\n        onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]\n    };\n};\nDcxNgTooltipComponent = __decorate([\n    Component({\n        selector: 'dcx-ng-tooltip',\n        standalone: true,\n        imports: [CommonModule],\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef])\n], DcxNgTooltipComponent);\nexport { DcxNgTooltipComponent };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}